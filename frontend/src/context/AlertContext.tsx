import { createContext, useContext, useState, ReactNode, useCallback, useEffect } from 'react';
import { api, Alert as ApiAlert } from '@/services/api';

// Enhanced alert lifecycle states
export type AlertStatus = 'new' | 'reviewed' | 'monitoring' | 'action_taken' | 'dismissed';

export interface Alert {
    id: string;
    patientId: string;
    patientName?: string;
    time: string;
    severity: 'critical' | 'high' | 'medium' | 'low';
    title: string;
    explanation: string;
    status: AlertStatus;
    feedback?: 'helpful' | 'not_helpful' | null;
    reviewedBy?: string;
    reviewedAt?: string;
    actionNote?: string;
    autoGenerated?: boolean;  // NEW: ML-generated vs manual
}

interface AlertContextType {
    alerts: Alert[];
    activeAlerts: Alert[];
    loading: boolean;
    error: string | null;
    refreshAlerts: () => Promise<void>;
    acknowledgeAlert: (alertId: string) => Promise<void>;
    dismissAlert: (alertId: string, userId?: string) => Promise<void>;
    setFeedback: (alertId: string, feedback: 'useful' | 'not_useful') => void;
    getAlertsByPatient: (patientId: string) => Alert[];
}

const AlertContext = createContext<AlertContextType | undefined>(undefined);

// Convert API alert to frontend Alert type
// Map old status to new lifecycle status
const mapApiStatus = (status: string): AlertStatus => {
    switch (status) {
        case 'active': return 'new';
        case 'acknowledged': return 'reviewed';
        case 'dismissed': return 'dismissed';
        default: return 'new';
    }
};

const convertApiAlert = (apiAlert: ApiAlert): Alert => ({
    id: apiAlert.id,
    patientId: apiAlert.patient_id,
    time: apiAlert.created_at,
    severity: apiAlert.severity,
    title: apiAlert.title,
    explanation: apiAlert.explanation || '',
    status: mapApiStatus(apiAlert.status),
    feedback: null,
    autoGenerated: apiAlert.auto_generated || false,
});

export function AlertProvider({ children }: { children: ReactNode }) {
    const [alerts, setAlerts] = useState<Alert[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    // Fetch alerts from database
    const refreshAlerts = useCallback(async () => {
        setLoading(true);
        setError(null);

        try {
            const data = await api.getAlerts();
            setAlerts(data.map(convertApiAlert));
        } catch (err) {
            console.error('Failed to fetch alerts:', err);
            setError(err instanceof Error ? err.message : 'Failed to load alerts');
        } finally {
            setLoading(false);
        }
    }, []);

    // Fetch on mount
    useEffect(() => {
        refreshAlerts();
    }, [refreshAlerts]);

    const acknowledgeAlert = useCallback(async (alertId: string) => {
        try {
            await api.acknowledgeAlert(alertId);
            setAlerts((prev) =>
                prev.map((alert) =>
                    alert.id === alertId
                        ? { ...alert, status: 'reviewed' as AlertStatus, reviewedAt: new Date().toISOString() }
                        : alert
                )
            );
        } catch (err) {
            console.error('Failed to acknowledge alert:', err);
        }
    }, []);

    const dismissAlert = useCallback(async (alertId: string) => {
        try {
            await api.dismissAlert(alertId);
            setAlerts((prev) =>
                prev.map((alert) =>
                    alert.id === alertId
                        ? { ...alert, status: 'dismissed' as const }
                        : alert
                )
            );
        } catch (err) {
            console.error('Failed to dismiss alert:', err);
        }
    }, []);

    const getAlertsByPatient = useCallback(
        (patientId: string) => alerts.filter((a) => a.patientId === patientId),
        [alerts]
    );

    const setFeedback = useCallback((alertId: string, feedback: 'useful' | 'not_useful') => {
        const mappedFeedback = feedback === 'useful' ? 'helpful' : 'not_helpful';
        setAlerts((prev) =>
            prev.map((alert) =>
                alert.id === alertId
                    ? { ...alert, feedback: mappedFeedback as 'helpful' | 'not_helpful' }
                    : alert
            )
        );
    }, []);

    const activeAlerts = alerts.filter((a) => a.status === 'new' || a.status === 'reviewed' || a.status === 'monitoring');

    return (
        <AlertContext.Provider
            value={{
                alerts,
                activeAlerts,
                loading,
                error,
                refreshAlerts,
                acknowledgeAlert,
                dismissAlert,
                setFeedback,
                getAlertsByPatient,
            }}
        >
            {children}
        </AlertContext.Provider>
    );
}

export function useAlerts() {
    const context = useContext(AlertContext);
    if (context === undefined) {
        throw new Error('useAlerts must be used within an AlertProvider');
    }
    return context;
}
